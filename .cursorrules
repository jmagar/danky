# Cursor Rules for Danky AI Chatbot

project:
  structure:
    apps:
      web:
        components:
          chat:
            - "Keep message components focused and small"
            - "Implement proper loading states"
            - "Use proper error boundaries"
            - "Keep chat layout components under 250 lines"
            - "Extract complex chat logic to custom hooks"
            - "Use proper TypeScript types from @danky/schema"
          sidebar:
            - "Follow consistent sidebar component structure"
            - "Use SidebarContext for state management"
            - "Keep sidebar components focused on single responsibility"
            - "Implement proper mobile responsiveness"
            - "Use proper TypeScript types for sidebar props"
          mcp:
            - "Keep MCP panel components focused"
            - "Implement proper tool selection handling"
            - "Use proper server and tool type definitions"
            - "Handle loading and error states properly"
          theme:
            - "Use ThemeProvider consistently"
            - "Implement proper theme toggle functionality"
            - "Follow dark/light mode patterns"
        hooks:
          - "Keep hooks focused and reusable"
          - "Implement proper cleanup in useEffect"
          - "Use proper TypeScript types"
          - "Handle mobile detection properly in useIsMobile"
        api:
          - "Implement proper error handling with custom error classes"
          - "Use zod for input validation"
          - "Follow RESTful patterns for routes"
          - "Use proper TypeScript types from @danky/schema"
          - "Implement proper session management"
    packages:
      ui:
        - "Keep UI components pure and reusable"
        - "Follow shadcn/ui patterns"
        - "Implement proper accessibility"
        - "Use proper TypeScript types"
        - "Keep components under 100 lines"
        - "Export components through index.ts"
      db:
        - "Use Drizzle for database operations"
        - "Keep migrations organized"
        - "Implement proper error handling"
        - "Use proper TypeScript types"
      redis:
        - "Implement proper client creation"
        - "Handle pub/sub patterns correctly"
        - "Use proper environment variables"
      qdrant:
        - "Implement proper vector operations"
        - "Handle collection management properly"
        - "Use proper environment variables"
      logger:
        - "Use Pino for logging"
        - "Implement proper log levels"
        - "Use proper environment variables"
  standards:
    files:
      length:
        react:
          component: 250
          hook: 100
          util: 200
        typescript:
          service: 200
          type: 100
          config: 150
    functions:
      - "Avoid duplicate function implementations"
      - "Use proper TypeScript types"
      - "Implement proper error handling"
      - "Keep functions focused and small"
    errors:
      - "Use custom error classes from lib/errors"
      - "Implement proper error boundaries"
      - "Handle database errors properly"
      - "Use proper error logging"
    state:
      - "Use proper context providers"
      - "Implement proper state management patterns"
      - "Keep state close to where it's used"
      - "Use proper TypeScript types for state"

typescript:
  - "No any types unless absolutely necessary"
  - "Use proper TypeScript types and interfaces"
  - "Use zod for runtime type validation"
  - "Keep files under 300 lines"
  - "Use proper error handling with custom error classes"
  - "Use async/await over raw promises"
  - "Use proper TypeScript path aliases (@/*)"
  - "Maintain strict TypeScript config"
  - "Use proper module resolution"
  - "Keep type definitions clean"
  - "Export types from dedicated type files"
  - "Use branded types for type safety"
  - "Prefer type inference where possible"

react:
  - "Use Server Components by default"
  - "Add 'use client' only when necessary"
  - "Keep components focused and small"
  - "Use proper prop typing"
  - "Use proper error boundaries"
  - "Follow Next.js App Router patterns"
  - "Keep pages simple, logic in components"
  - "Use proper loading and error states"
  - "Follow React 18 best practices"
  - "Implement proper Suspense boundaries"
  - "Use proper metadata"
  - "Keep client bundles small"
  - "Implement root error boundary for app-wide errors"
  - "Create reusable error boundary components"
  - "Use error boundaries for specific feature sections"
  - "Handle errors gracefully with user-friendly fallbacks"
  - "Add shadcn components using pnpm dlx shadcn@latest add"
  - "Never modify shadcn component source files directly"
  - "Create wrapper components for shadcn customizations"
  - "Keep shadcn component variants in theme configuration"
  - "Follow shadcn component composition patterns"
  - "Extract complex logic to custom hooks"
  - "Use composition over inheritance"
  - "Keep state management close to where it's used"
  - "Use proper form handling with react-hook-form"
  - "Use shadcn's built-in animations and transitions"
  - "Keep animations performant"
  - "Use proper event handling"

ui:
  - "Follow consistent spacing patterns"
  - "Use CSS variables for theming"
  - "Keep components accessible"
  - "Follow ARIA best practices"
  - "Support dark/light modes"
  - "Use proper responsive design"
  - "Keep animations smooth"
  - "Use proper loading states"
  - "Follow consistent component patterns"
  - "Use proper typography scale"
  - "Keep UI components pure"
  - "Use proper color contrast"
  - "Support RTL languages"
  - "Use proper focus management"
  - "Keep components DRY"

hooks:
  - "Keep hooks focused and reusable"
  - "Use proper dependency arrays"
  - "Handle cleanup properly"
  - "Use proper TypeScript typing"
  - "Keep side effects contained"
  - "Use proper error handling"
  - "Follow naming conventions"
  - "Document hook usage"
  - "Test hooks thoroughly"
  - "Keep hooks pure when possible"

services:
  - "Keep services focused"
  - "Use proper dependency injection"
  - "Handle errors properly"
  - "Use proper TypeScript typing"
  - "Keep services testable"
  - "Use proper logging"
  - "Follow proper cleanup patterns"
  - "Document service usage"
  - "Use proper configuration"
  - "Keep services stateless when possible"

database:
  - "Use Drizzle for all database operations"
  - "Keep schema definitions clean and documented"
  - "Use proper indexes"
  - "Use transactions where necessary"
  - "Proper error handling for DB operations"
  - "Use connection pooling via pgbouncer"
  - "Keep migrations organized"
  - "Use proper schema versioning"
  - "Implement proper constraints"
  - "Follow database naming conventions"
  - "Group related schema definitions"
  - "Use explicit foreign key relationships"
  - "Implement proper migration rollbacks"
  - "Follow semantic versioning for migrations"
  - "Keep migrations atomic and focused"
  - "Use prepared statements for all queries"
  - "Implement proper connection retries and timeouts"

api:
  - "Use proper HTTP status codes"
  - "Validate all inputs with zod"
  - "Proper error responses"
  - "Use Next.js Server Actions where appropriate"
  - "Keep endpoints RESTful"
  - "Document API endpoints"
  - "Implement proper rate limiting"
  - "Use proper caching strategies"
  - "Follow API versioning conventions"
  - "Implement proper security headers"

mcp:
  core:
    - "Follow JSON-RPC 2.0 protocol standards"
    - "Implement proper tool registration and discovery"
    - "Use Zod for schema validation"
    - "Implement proper cleanup functions"
    - "Handle environment variables securely"
    - "Validate all configurations"
    - "Implement proper error handling with custom classes"
    - "Follow concurrent initialization patterns"
    - "Keep tool implementations modular"
    - "Implement proper tool lifecycle management"
    - "Use proper error codes and messages"
    - "Follow proper tool naming conventions"
    - "Implement proper tool versioning"
    - "Document tool capabilities and limitations"
    - "Implement proper rate limiting for LLM calls"
    - "Handle streaming responses correctly"
    - "Implement proper token counting and management"
    - "Handle context window limitations appropriately"

  security:
    - "Secure credential management via .env"
    - "Validate all tool inputs and outputs"
    - "Implement proper access control"
    - "Use secure transport layers"
    - "Follow proper logging practices"
    - "Handle errors gracefully"
    - "Clean up resources properly"
    - "Validate server configurations"
    - "Protect sensitive information"
    - "Follow AI safety guidelines"

  langchain:
    - "Convert MCP servers to LangChain tools correctly"
    - "Implement proper tool binding"
    - "Handle tool execution properly"
    - "Filter and format results appropriately"
    - "Support multiple LLM providers"
    - "Implement proper memory management"
    - "Follow ReAct agent patterns"
    - "Handle tool state properly"
    - "Implement proper fallbacks"
    - "Keep prompts organized and clean"

  config:
    - "Use JSON5 for config files"
    - "Handle environment variable substitution"
    - "Validate all config fields"
    - "Implement proper defaults"
    - "Support multiple server configs"
    - "Handle server-specific settings"
    - "Implement proper cleanup"
    - "Support dynamic configuration"
    - "Follow naming conventions"
    - "Document all options"

testing:
  - "Use Vitest for all tests"
  - "Mock external services"
  - "Test error cases"
  - "Keep tests focused"
  - "Use proper test descriptions"
  - "Implement proper test coverage"
  - "Use proper test fixtures"
  - "Follow testing best practices"
  - "Test edge cases"
  - "Keep tests maintainable"
  - "Implement proper cleanup in tests"
  - "Use proper test organization"
  - "Follow test naming conventions"
  - "Test both success and failure paths"
  - "Implement proper test isolation"
  - "Test streaming responses"
  - "Test LLM interactions"
  - "Implement proper test data factories"

state:
  - "Use Zustand for client state"
  - "Keep stores focused"
  - "Use proper TypeScript types"
  - "Implement proper persistence where needed"
  - "Follow store naming conventions"
  - "Keep state normalized"
  - "Implement proper selectors"
  - "Use proper middleware"
  - "Follow immutability patterns"
  - "Document store structure"
  - "Implement proper store slicing"
  - "Use proper action creators"
  - "Follow proper state update patterns"
  - "Implement proper store composition"
  - "Keep stores minimal and focused"
  - "Handle hydration correctly"
  - "Implement proper state revalidation"

packages:
  - "Keep packages focused"
  - "Maintain clean public APIs"
  - "Proper package documentation"
  - "Follow semantic versioning"
  - "Keep dependencies minimal"
  - "Use proper exports"
  - "Follow package naming conventions"
  - "Implement proper package tests"
  - "Keep package size optimal"
  - "Document breaking changes"
  - "Follow src/types/utils structure"
  - "Implement proper entry points"
  - "Use proper package boundaries"
  - "Follow proper export patterns"
  - "Keep package interfaces clean"

general:
  - "Use proper error tracking with Sentry"
  - "Implement proper logging with Pino"
  - "Follow OpenTelemetry practices"
  - "Keep code DRY"
  - "Use proper commenting"
  - "Follow project structure"
  - "Use proper environment variables"
  - "Follow security best practices"
  - "Keep dependencies updated"
  - "Follow code review guidelines"
  - "Implement proper cleanup functions"
  - "Follow proper error handling patterns"
  - "Use proper type safety"
  - "Follow proper naming conventions"
  - "Keep code modular and reusable"
